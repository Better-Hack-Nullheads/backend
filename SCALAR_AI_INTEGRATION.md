# Scalar + AI Integration Guide

## üéØ Best of Both Worlds: Scalar + AI

### The Smart Approach:

1. **Scalar** ‚Üí Generates perfect OpenAPI spec from TypeScript
2. **Our AI** ‚Üí Enhances the spec with intelligent documentation
3. **Result** ‚Üí Professional route detection + AI-powered docs

## üöÄ Implementation Plan

### Step 1: Generate OpenAPI Spec with Scalar

```bash
# Install Swagger for NestJS
npm install @nestjs/swagger swagger-ui-express

# Add Swagger to your NestJS app (see SCALAR_INTEGRATION.md)
# This generates perfect OpenAPI spec automatically
```

### Step 2: Extract OpenAPI Data for AI

```typescript
// src/services/scalar-ai-service.ts
import { readFileSync } from 'fs';
import { join } from 'path';
import { AIService } from './ai-service';

export class ScalarAIService {
  private aiService: AIService;

  constructor(aiService: AIService) {
    this.aiService = aiService;
  }

  async generateEnhancedDocs(openApiSpecPath: string): Promise<string> {
    // 1. Read OpenAPI spec generated by Scalar
    const openApiSpec = JSON.parse(readFileSync(openApiSpecPath, 'utf-8'));

    // 2. Transform OpenAPI spec to our AI format
    const aiInput = this.transformOpenApiToAIFormat(openApiSpec);

    // 3. Send to AI for enhanced documentation
    const enhancedDocs = await this.aiService.analyzeProject(aiInput);

    return enhancedDocs;
  }

  private transformOpenApiToAIFormat(openApiSpec: any): any {
    const routes: any[] = [];
    const controllers: any[] = [];
    const services: any[] = [];
    const types: any[] = [];

    // Extract routes from OpenAPI paths
    Object.entries(openApiSpec.paths || {}).forEach(
      ([path, methods]: [string, any]) => {
        Object.entries(methods).forEach(
          ([method, operation]: [string, any]) => {
            routes.push({
              path,
              method: method.toUpperCase(),
              handler: operation.operationId || 'unknown',
              parameters: this.extractParameters(operation.parameters || []),
              responses: operation.responses || {},
              summary: operation.summary || '',
              description: operation.description || '',
              tags: operation.tags || [],
              framework: 'nestjs',
              source: 'openapi',
            });
          },
        );
      },
    );

    // Extract types from OpenAPI components
    Object.entries(openApiSpec.components?.schemas || {}).forEach(
      ([name, schema]: [string, any]) => {
        types.push({
          name,
          properties: schema.properties || {},
          required: schema.required || [],
          type: schema.type || 'object',
          description: schema.description || '',
        });
      },
    );

    // Group routes by tags (controllers)
    const tagGroups = new Map<string, any[]>();
    routes.forEach((route) => {
      route.tags.forEach((tag: string) => {
        if (!tagGroups.has(tag)) {
          tagGroups.set(tag, []);
        }
        tagGroups.get(tag)!.push(route);
      });
    });

    // Create controllers from tag groups
    tagGroups.forEach((tagRoutes, tag) => {
      controllers.push({
        name: `${tag}Controller`,
        routes: tagRoutes,
        framework: 'nestjs',
        filePath: `src/${tag}/${tag}.controller.ts`,
      });
    });

    return {
      framework: 'nestjs',
      routes,
      controllers,
      services,
      types,
      metadata: {
        totalRoutes: routes.length,
        totalControllers: controllers.length,
        totalServices: services.length,
        totalTypes: types.length,
        analysisTime: 0,
        source: 'openapi',
      },
    };
  }

  private extractParameters(parameters: any[]): any[] {
    return parameters.map((param) => ({
      name: param.name,
      type: param.schema?.type || 'string',
      optional: !param.required,
      decorator:
        param.in === 'path'
          ? 'Param'
          : param.in === 'query'
            ? 'Query'
            : param.in === 'body'
              ? 'Body'
              : 'unknown',
      description: param.description || '',
    }));
  }
}
```

### Step 3: Update CLI to Use Scalar + AI

```typescript
// src/cli.ts - Add new command
program
  .command('scalar-ai')
  .description('Generate AI documentation from Scalar OpenAPI spec')
  .argument('<openapi-path>', 'Path to OpenAPI spec file')
  .option('-o, --output <file>', 'Output file path')
  .action(async (openApiPath, options) => {
    try {
      console.log('ü§ñ Generating AI documentation from Scalar OpenAPI spec...');

      const config = configManager.getConfig();
      const aiService = new AIService(config.ai);
      const scalarAIService = new ScalarAIService(aiService);

      const enhancedDocs =
        await scalarAIService.generateEnhancedDocs(openApiPath);

      const outputPath = options.output || 'docs/scalar-ai-docs.md';
      writeFileSync(outputPath, enhancedDocs);

      console.log(`‚úÖ Enhanced documentation saved to ${outputPath}`);
    } catch (error) {
      console.error('‚ùå Scalar AI documentation generation failed:', error);
      process.exit(1);
    }
  });
```

### Step 4: Enhanced AI Prompt for OpenAPI Data

```typescript
// src/utils/scalar-prompt-templates.ts
export class ScalarPromptTemplates {
  static getOpenAPITemplate(): string {
    return `
You are a technical writer specialized in API documentation. You have been given a professional OpenAPI specification generated by Scalar from a TypeScript project.

Your goal is to create comprehensive, user-friendly documentation that enhances the technical OpenAPI spec with:

üéØ **Enhanced Documentation Requirements**

**API Overview**
- Create a clear, business-focused description of what this API does
- Explain the main use cases and workflows
- Add getting started guide for developers

**Endpoint Documentation**
- Transform technical OpenAPI data into developer-friendly explanations
- Add practical examples and use cases
- Include common error scenarios and troubleshooting

**Code Examples**
- Provide working code examples in multiple languages (TypeScript, JavaScript, cURL, Python)
- Show real-world usage patterns
- Include authentication examples

**Integration Guide**
- Explain how to integrate with this API
- Provide SDK examples if applicable
- Include rate limiting and best practices

**Error Handling**
- Document common error responses
- Provide troubleshooting guides
- Include status code explanations

---

## OpenAPI Specification Data:
\`\`\`json
${JSON.stringify(analysisData, null, 2)}
\`\`\`

Generate professional, comprehensive documentation that transforms this technical specification into developer-friendly content.
`;
  }
}
```

## üéØ Usage Workflow

### 1. Setup Scalar (One-time)

```bash
# Install Swagger
npm install @nestjs/swagger swagger-ui-express

# Add Swagger to main.ts
# Add decorators to controllers
# Start your app
npm run start:dev
```

### 2. Generate OpenAPI Spec

```bash
# Access your OpenAPI spec at http://localhost:3000/api-json
# Save it to a file
curl http://localhost:3000/api-json > docs/openapi.json
```

### 3. Generate AI Documentation

```bash
# Use our AI to enhance the Scalar-generated spec
npx auto-doc-gen-universal scalar-ai docs/openapi.json -o docs/enhanced-docs.md
```

### 4. Serve with Scalar UI

```bash
# Serve the enhanced documentation with Scalar UI
npx @scalar/cli serve --input docs/openapi.json --port 3001
```

## üìä Benefits of Scalar + AI Approach

| Feature                   | Scalar Only  | AI Only      | Scalar + AI     |
| ------------------------- | ------------ | ------------ | --------------- |
| **Route Detection**       | ‚úÖ Perfect   | ‚ùå Hardcoded | ‚úÖ Perfect      |
| **Type Safety**           | ‚úÖ Built-in  | ‚ùå Manual    | ‚úÖ Built-in     |
| **Documentation Quality** | ‚úÖ Technical | ‚úÖ Enhanced  | ‚úÖ Professional |
| **Code Examples**         | ‚ùå Basic     | ‚úÖ Rich      | ‚úÖ Rich         |
| **Business Context**      | ‚ùå Missing   | ‚úÖ Added     | ‚úÖ Added        |
| **Maintenance**           | ‚úÖ Zero      | ‚ùå High      | ‚úÖ Low          |

## üöÄ Advanced Features

### Chunked AI Documentation from OpenAPI

```typescript
// Generate chunked docs from OpenAPI spec
program
  .command('scalar-ai-chunks')
  .description('Generate chunked AI documentation from Scalar OpenAPI spec')
  .argument('<openapi-path>', 'Path to OpenAPI spec file')
  .action(async (openApiPath) => {
    const scalarAIService = new ScalarAIService(aiService);
    const aiInput = scalarAIService.transformOpenApiToAIFormat(openApiSpec);

    // Use existing chunked generation logic
    const chunks = groupRoutesByController(aiInput.routes, aiInput.controllers);

    for (const [moduleName, moduleRoutes] of Object.entries(chunks)) {
      const moduleData = {
        ...aiInput,
        routes: moduleRoutes,
        metadata: { ...aiInput.metadata, moduleName },
      };

      const moduleDocs = await aiService.analyzeProject(moduleData);
      writeFileSync(`docs/chunks/${moduleName}.md`, moduleDocs);
    }
  });
```

### Real-time OpenAPI + AI Updates

```typescript
// Watch for OpenAPI spec changes and regenerate AI docs
program
  .command('scalar-ai-watch')
  .description('Watch OpenAPI spec and regenerate AI docs on changes')
  .argument('<openapi-path>', 'Path to OpenAPI spec file')
  .action(async (openApiPath) => {
    const watcher = chokidar.watch(openApiPath);

    watcher.on('change', async () => {
      console.log('üîÑ OpenAPI spec changed, regenerating AI docs...');
      const enhancedDocs =
        await scalarAIService.generateEnhancedDocs(openApiPath);
      writeFileSync('docs/enhanced-docs.md', enhancedDocs);
      console.log('‚úÖ AI docs updated');
    });
  });
```

## üéØ Final Recommendation

**Use Scalar + AI approach:**

1. **Scalar** handles the hard part (route detection, type safety)
2. **Our AI** adds the value (enhanced documentation, examples, context)
3. **Result** = Professional tool + AI enhancement = Best of both worlds

This approach gives you:

- ‚úÖ Perfect route detection (Scalar)
- ‚úÖ Enhanced documentation (AI)
- ‚úÖ Zero maintenance for route detection
- ‚úÖ Focus on AI improvements
- ‚úÖ Professional output

---

**This is the smart way to build on existing professional tools instead of reinventing the wheel!**
